(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{194:function(e,t,a){"use strict";a.r(t);var i=a(0),n=Object(i.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"staking"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#staking","aria-hidden":"true"}},[e._v("#")]),e._v(" Staking")]),e._v(" "),a("p",[e._v("This doc cointains the specification of the initial staking, slashing, fees and rewards mechanisms.")]),e._v(" "),a("h2",{attrs:{id:"account"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#account","aria-hidden":"true"}},[e._v("#")]),e._v(" Account")]),e._v(" "),a("p",[e._v("Account is a data structure that holds state about staking:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("pub struct Account {\n    pub nonce: usize, // transaction counter\n    pub bonded: Coin, // bonded staked amount\n    pub unbonded: Coin, // unbonded staked amount\n    pub unbonded_from: Timespec, // when the unboded staked amount can be withdrawn\n    pub address: RedeemAddress, // ETH-style address; TODO: extended address?\n    pub jailed_until: Option<Timespec>, // has the account been jailed in slashing-related logic?\n    pub slashed: Option<SlashingPeriod>, // how much is the account supposed to be slashed in slashing-related logic?\n}\n")])])]),a("p",[e._v("TODO: should it have a minimum bonded amount?")]),e._v(" "),a("h2",{attrs:{id:"council-node"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#council-node","aria-hidden":"true"}},[e._v("#")]),e._v(" Council Node")]),e._v(" "),a("p",[e._v("Council Node is a data structure that holds state about a node responsible for transaction validation and service node whitelist management:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("pub struct CouncilNode {\n    pub staking_address: RedeemAddress, // account with the required staked amount\n    pub consensus_pubkey: crypto.PubKey, // Tendermint consensus validator-associated public key: note that Tendermint supports different signature schemes\n    pub council_pubkey: PublicKey, // key for council node-related transaction types\n    pub service_whitelist_pubkey: PublicKey, // key for service node whitelist-related transaction types\n    pub nonce: usize, // update counter\n}\n")])])]),a("h2",{attrs:{id:"service-node"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#service-node","aria-hidden":"true"}},[e._v("#")]),e._v(" Service Node")]),e._v(" "),a("p",[e._v("Service Node is a data structure that holds state about a high responsibility node and its offered service:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("pub struct ServiceNode {\n    pub staking_address: RedeemAddress, // account with the required staked amount\n    pub service_pubkey: PublicKey, // key for service node whitelist entry updates\n    pub service_type: ServiceNodeType, // what service this node offers\n    pub service_url: URL, // HTTPS endpoint of the provided service\n    pub nonce: usize, // update counter\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("pub enum ServiceNodeType {\n    CustomerAcquirer, // (optional) custodial multi-currency wallet provider\n    MerchantAcquirer, // (optional) verified merchant ID management provider, payment gateway, merchant custodial currency risk management and per-agreement fiat settlements (most initial on-boarded merchants will most likely prefer to avoid volatility risks)\n    SettlementAgent, // provides currency exchange service (e.g. via IBC and DEX)\n}\n")])])]),a("p",[e._v("As most of the functionality is meant to faciliate some actions outside Chain, the information is recorded in the flexible form of storing a URL pointing to HTTPS API. These API endpoints will either directly execute some action or return information required for the action to be executed (e.g. other protocol’s details).")]),e._v(" "),a("h2",{attrs:{id:"transaction-fee"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transaction-fee","aria-hidden":"true"}},[e._v("#")]),e._v(" Transaction Fee")]),e._v(" "),a("p",[e._v("The minimal transaction fee is defined according to the formula:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<BASE_AMOUNT> + <PER_BYTE> * size\n")])])]),a("p",[a("code",[e._v("BASE_AMOUNT")]),e._v(" and "),a("code",[e._v("PER_BYTE")]),e._v(" are special network parameters in a fraction of CRO. "),a("code",[e._v("size")]),e._v(" is the serialized transaction data’s size in bytes.")]),e._v(" "),a("p",[e._v("Basic ("),a("code",[e._v("TransferTX")]),e._v(", "),a("code",[e._v("DepositStakeTx")]),e._v(", "),a("code",[e._v("WithdrawUnbondedTx")]),e._v(", "),a("code",[e._v("UnbondStakeTx")]),e._v(",) transaction types need to check")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("sum(inputs amounts) or account.unbonded/bonded == sum(outputs amounts) + fee\n")])])]),a("p",[e._v("The fee goes to the rewards pool.")]),e._v(" "),a("p",[e._v("For Advanced TX types (council node and service node state metadata management), the initial prototype will not require a fee.")]),e._v(" "),a("h2",{attrs:{id:"rewards"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rewards","aria-hidden":"true"}},[e._v("#")]),e._v(" Rewards")]),e._v(" "),a("p",[e._v("The rewards pool is a data structure that stores the information about remaining funds:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("pub struct RewardsPool {\n    pub nonce: usize, // update counter\n    pub total_remaining: Coin, // total available amount\n    pub last_update: Timespec, // when was the pool last updated\n}\n")])])]),a("p",[e._v("The initial prototype will have a "),a("code",[e._v("DAILY_DISTRIBUTION_AMOUNT")]),e._v(" network parameter; later on, it should be a function that takes a target emission rate, total remaining amount etc. as parameters.")]),e._v(" "),a("h3",{attrs:{id:"distribution"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#distribution","aria-hidden":"true"}},[e._v("#")]),e._v(" Distribution")]),e._v(" "),a("p",[e._v("Each validator will maintain this structures (perhaps persistent / on-disk): "),a("code",[e._v("day_claim_council_node: Map<CouncilNode, BlockCount>")])]),e._v(" "),a("p",[e._v("The actual distribution then happens once in a while in BeginBlock, here’s a pseudo code:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("for each validator in BeginBlock.LastCommitInfo:\n    lookup validator's staking_address\n    if day_claim_council_node[validator_day_claim_council_node] is Nil:\n        day_claim_council_node[validator_day_claim_council_node] = 0\n    day_claim_council_node[validator_day_claim_council_node] += 1\n\nfor each node in day_claim_council_node:\n    if node.staking_address.jailed_until.is_some() OR node.staking_address.jailed_until.is_some() OR\n    node.slashed.is_some() OR\n    node.staking_address.bonded < COUNCIL_NODE_MIN_STAKE:\n        remove node from claim set\n\nif BeginBlock.time >= RewardsPool.last_update + 24 hours:\n    validator_amount = min(DAILY_DISTRIBUTION_AMOUNT, RewardsPool.total_remaining)\n\n    for each node in day_claim_council_node:\n        node_share = compute_share(node, day_claim_council_node, validator_amount)\n        END/COMMIT_BLOCK_STATE_UPDATE(node.staking_address.bonded += node_share; node.staking_address.nonce += 1)\n\n    END/COMMIT_BLOCK_STATE_UPDATE(RewardsPool.total_remaining -= amount; RewardsPool.nonce += 1; RewardsPool.last_update = BeginBlock.time)\n    day_claim_council_node = {}\n")])])]),a("p",[a("code",[e._v("compute_share")]),e._v(" determines the amount for each claiming node; the initial prototype will compute it:")]),e._v(" "),a("ul",[a("li",[e._v("council nodes: proportional to the signed block count (node block signatures / all block validators signatures)")])]),e._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[e._v("NOTE")]),e._v(" "),a("p",[e._v("The draft technical whitepaper says there will be rewards for acquirer nodes. These terms may be revised in later drafts.")])]),e._v(" "),a("h2",{attrs:{id:"slashing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#slashing","aria-hidden":"true"}},[e._v("#")]),e._v(" Slashing")]),e._v(" "),a("p",[e._v("This part describes functionality that aims to disincentivize network-observable actions, such as faulty validations, of participants with values at stake by penalizing/slashing them. The penalties may include losing some amount of their stake (surrendered to the rewards pool), losing their ability to perform the network functionality for a period of time, collect rewards etc.")]),e._v(" "),a("h3",{attrs:{id:"slashing-period"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#slashing-period","aria-hidden":"true"}},[e._v("#")]),e._v(" Slashing period")]),e._v(" "),a("p",[e._v("Some of the faulty behavior may be non-malicious, e.g. due to misconfiguration. In order to mitigate the impact of these initially likely categories of faults, there is a concept of a slashing period whereby the penalty is capped. As penalties are specified in fixed decimal fractions of a stake, it is the highest fraction. In other words, in a given period, a violator is punished for the worst violation rather than losing all stake.")]),e._v(" "),a("p",[e._v("Even with this “more tolerant” punishment setup, it will still be quite expensive and desirable to avoid. Note that this setup must be accompanied by immediate jailing / limiting the violater’s network ability.")]),e._v(" "),a("p",[e._v("This is a sketched out additional data structure to keep track of (a part of Account):")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("pub struct SlashingPeriod {\n    pub start: Timespec, // when the period started,\n    pub end: Timespec, // when the period ended,\n    pub slashed_ratio: Decimal, // fixed decimal; cumulative so far slashed fraction; 0.0 initially\n}\n")])])]),a("h3",{attrs:{id:"unjail"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unjail","aria-hidden":"true"}},[e._v("#")]),e._v(" Unjail")]),e._v(" "),a("p",[e._v("When the previous violator wishes to resume the functionality, the node operator can send a signed "),a("code",[e._v("UnjailTx")]),e._v(". Its validation logic is the following:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('block_time = (... from beginblock ...)\naccount = (...lookup / recover from signature...)\nif account not found:\n    return invalid("account not found")\n\nif account.jailed_until.is_none():\n    return invalid("account not jailed")\n\nif nonce != account.nonce + 1:\n    return invalid("invalid nonce")\n\nif block_time < account.jailed_until.unwrap() || (account.slashed.is_some() && account.slashed.end > block_time):\n    return invalid("account still jailed")\n\nif !check_signature(txid):\n    return invalid("invalid signature")\n\nEND/COMMIT_BLOCK_STATE_UPDATE(deduct(account); account.jailed = None)\n')])])]),a("p",[e._v("TODO: auto-unjailing?")]),e._v(" "),a("h3",{attrs:{id:"tracking"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tracking","aria-hidden":"true"}},[e._v("#")]),e._v(" Tracking")]),e._v(" "),a("h4",{attrs:{id:"validators-council-nodes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#validators-council-nodes","aria-hidden":"true"}},[e._v("#")]),e._v(" Validators / Council Nodes")]),e._v(" "),a("p",[e._v("Each BeginBlock contains two fields that will determine penalties:")]),e._v(" "),a("ul",[a("li",[e._v("LastCommitInfo: this contains information which validators signed the last block")]),e._v(" "),a("li",[e._v("ByzantineValidators: evidence of validators that acted maliciously")])]),e._v(" "),a("p",[e._v("Their processing is the following:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("for each evidence in ByzantineValidators:\n    if evidence.Timestamp >= BeginBlock.Timestamp - MAX_EVIDENCE_AGE:\n        account = (... get corresponding account ...)\n        if account.slashing_period.end is set and it's before BeginBlock.Timestamp:\n            account.slashing_period.slashed_ratio = max(account.slashing_period.slashed_ratio, BYZANTINE_SLASH_RATIO)\n        else:\n            if account.slashing_period.end is set and it's after BeginBlock.Timestamp:\n                END/COMMIT_BLOCK_STATE_UPDATE(deduct(slashing_period, account))\n\n            account.slashing_period = Some(SlashingPeriod(start = Some(BeginBlock.Timestamp),\n                end = Some(BeginBlock.Timestamp + SLASHING_PERIOD_DURATION, slashed_ratio = BYZANTINE_SLASH_RATIO)))\n            account.jailed_until = Some(BeginBlock.Timestamp + JAIL_DURATION)\n\n\nfor each signer in LastCommitInfo:\n    council_node = (... lookup by signer / tendermint validator key ...)\n    update(council_node, BLOCK_SIGNING_WINDOW)\n\nfor each council_node:\n    missed_blocks = get_missed_signed_blocks(council_node)\n    if missed_blocks / BLOCK_SIGNING_WINDOW >= MISSED_BLOCK_THRESHOLD:\n        account = (... lookup corresponding account ...)\n        if account.slashing_period.end is set and it's before BeginBlock.Timestamp:\n            account.slashing_period.slashed_ratio = max(account.slashing_period.slashed_ratio, LIVENESS_SLASH_RATIO)\n        else:\n            if account.slashing_period.end is set and it's after BeginBlock.Timestamp:\n                END/COMMIT_BLOCK_STATE_UPDATE(deduct(slashing_period, account))\n\n            account.slashing_period = Some(SlashingPeriod(start = Some(BeginBlock.Timestamp),\n                end = Some(BeginBlock.Timestamp + SLASHING_PERIOD_DURATION, slashed_ratio = LIVENESS_SLASH_RATIO)))\n            account.jailed_until = Some(BeginBlock.Timestamp + JAIL_DURATION)\n")])])]),a("h2",{attrs:{id:"“global-state”-app-hash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#“global-state”-app-hash","aria-hidden":"true"}},[e._v("#")]),e._v(" “Global state” / APP_HASH")]),e._v(" "),a("p",[e._v("Tendermint expects a single compact value, "),a("code",[e._v("APP_HASH")]),e._v(", after each BlockCommit that represents the state of the application. In the early Chain prototype, this was constructed as a root of a Merkle tree from IDs of valid transactions.")]),e._v(" "),a("p",[e._v("In this staking scenario, some form of “chimeric ledger” needs to be employed, as staking-related functionality is represented with accounts. In Eth, Merkle Patricia Trees are used: https://github.com/ethereum/wiki/wiki/Design-Rationale#merkle-patricia-trees (The alternative in TM: https://github.com/tendermint/iavl depends on the order of transactions though)")]),e._v(" "),a("p",[e._v("They could possibly be used to represent an UTXO set: https://medium.com/codechain/codechains-merkleized-utxo-set-c76c9376fd4f")]),e._v(" "),a("p",[e._v("The overall “global state” then consists of the following items:")]),e._v(" "),a("ul",[a("li",[e._v("UTXO set")]),e._v(" "),a("li",[e._v("Account")]),e._v(" "),a("li",[e._v("RewardsPool")]),e._v(" "),a("li",[e._v("CouncilNode")]),e._v(" "),a("li",[e._v("ServiceNode")]),e._v(" "),a("li",[e._v("MerchantWhitelist (not yet spec-out / TODO)")])]),e._v(" "),a("p",[e._v("So each component could possibly be represented as MPT and these MPTs would then be combined together to form a single "),a("code",[e._v("APP_HASH")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"network-parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#network-parameters","aria-hidden":"true"}},[e._v("#")]),e._v(" Network Parameters")]),e._v(" "),a("p",[e._v("This section aims to collect all the mentioned network parameters:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("BASE_AMOUNT")])]),e._v(" "),a("li",[a("code",[e._v("PER_BYTE")])]),e._v(" "),a("li",[a("code",[e._v("COMMUNITY_NODE_MIN_STAKE")])]),e._v(" "),a("li",[a("code",[e._v("DAILY_DISTRIBUTION_AMOUNT")])]),e._v(" "),a("li",[a("code",[e._v("PER_MERCHANT_MIN_STAKE")])]),e._v(" "),a("li",[a("code",[e._v("CUSTOMER_ACQUIRER_NODE_MIN_STAKE")])]),e._v(" "),a("li",[a("code",[e._v("COUNCIL_NODE_MIN_STAKE")])]),e._v(" "),a("li",[a("code",[e._v("MAX_EVIDENCE_AGE")]),e._v(" (Note that currently in EvidenceParams of ABCI, there’s MaxAge set in the number of blocks, but here we assume time)")]),e._v(" "),a("li",[a("code",[e._v("SLASHING_PERIOD_DURATION")])]),e._v(" "),a("li",[a("code",[e._v("JAIL_DURATION")])]),e._v(" "),a("li",[a("code",[e._v("BLOCK_SIGNING_WINDOW")])]),e._v(" "),a("li",[a("code",[e._v("MISSED_BLOCK_THRESHOLD")])]),e._v(" "),a("li",[a("code",[e._v("BYZANTINE_SLASH_RATIO")])]),e._v(" "),a("li",[a("code",[e._v("LIVENESS_SLASH_RATIO")])])]),e._v(" "),a("p",[e._v("TODO: TX that can change them?")]),e._v(" "),a("h3",{attrs:{id:"end-commit-block-state-update"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#end-commit-block-state-update","aria-hidden":"true"}},[e._v("#")]),e._v(" END/COMMIT_BLOCK_STATE_UPDATE")]),e._v(" "),a("p",[e._v("Besides committing all the relevant changes and computing the resulting "),a("code",[e._v("APP_HASH")]),e._v(" in BlockCommit; for all changes in Accounts, the implementation needs to signal "),a("code",[e._v("ValidatorUpdate")]),e._v(" in EndBlock if the change is relevant to the council node’s staking address:")]),e._v(" "),a("ul",[a("li",[e._v("if the "),a("code",[e._v("bonded")]),e._v(" amount changes and >= "),a("code",[e._v("COUNCIL_NODE_MIN_STAKE")]),e._v(", then the validator’s power should be set to that amount")]),e._v(" "),a("li",[e._v("if the "),a("code",[e._v("bonded")]),e._v(" amount changes and < "),a("code",[e._v("COUNCIL_NODE_MIN_STAKE")]),e._v(", then the validator’s power should be set 0")]),e._v(" "),a("li",[e._v("if the "),a("code",[e._v("jailed_until")]),e._v(" changes to "),a("code",[e._v("Some(...)")]),e._v(", then the validator’s power should be set 0")]),e._v(" "),a("li",[e._v("if the "),a("code",[e._v("jailed_until")]),e._v(" changes to "),a("code",[e._v("None")]),e._v(" (unjailtx or auto?) and "),a("code",[e._v("bonded")]),e._v(" amount >= "),a("code",[e._v("COUNCIL_NODE_MIN_STAKE")]),e._v(", then the validator’s power should be set to the "),a("code",[e._v("bonded")]),e._v(" amount")])]),e._v(" "),a("h3",{attrs:{id:"initchain"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#initchain","aria-hidden":"true"}},[e._v("#")]),e._v(" InitChain")]),e._v(" "),a("p",[e._v("The initial prototype’s configuration will need to contain the following elements:")]),e._v(" "),a("ul",[a("li",[e._v("Above network parameters")]),e._v(" "),a("li",[e._v("ERC20 snapshot state / holder mapping "),a("code",[e._v("initial_holders")]),e._v(":\n"),a("code",[e._v("Vec<(address: RedeemAddress, is_contract: bool, amount: Coin)>")]),e._v(" (or "),a("code",[e._v("Map<RedeemAddress, (bool, Coin)>")]),e._v(")")]),e._v(" "),a("li",[e._v("Network long-term incentive address: "),a("code",[e._v("nlt_address")])]),e._v(" "),a("li",[e._v("Secondary distribution and launch incentive addresses: "),a("code",[e._v("dist_address1")]),e._v(", "),a("code",[e._v("dist_address2")])]),e._v(" "),a("li",[e._v("initial validators: "),a("code",[e._v("Vec<CouncilNode>")])]),e._v(" "),a("li",[e._v("bootstrap nodes / initially bonded: "),a("code",[e._v("Vec<RedeemAddress>")])])]),e._v(" "),a("p",[e._v("The validation of the configuration is the following:")]),e._v(" "),a("ol",[a("li",[e._v("validate parameters format (e.g. CUSTOMER_ACQUIRER_SHARE + MERCHANT_ACQUIRER_SHARE + COUNCIL_NODE_SHARE = 1.0)")]),e._v(" "),a("li",[e._v("check that sum of amounts in "),a("code",[e._v("initial_holders")]),e._v(" == MAX_COIN (network constant)")]),e._v(" "),a("li",[e._v("check there are no duplicate addresses (if Vec) in "),a("code",[e._v("initial_holders")])]),e._v(" "),a("li",[e._v("for each "),a("code",[e._v("council_node")]),e._v(" in "),a("code",[e._v("Vec<CouncilNode>")]),e._v(": check "),a("code",[e._v("staking_address")]),e._v(" is in "),a("code",[e._v("initial_holders")]),e._v(" and the amount >= "),a("code",[e._v("COUNCIL_NODE_MIN_STAKE")])]),e._v(" "),a("li",[e._v("for each "),a("code",[e._v("address")]),e._v(" in initially bonded "),a("code",[e._v("Vec<RedeemAddress>")]),e._v(": check "),a("code",[e._v("address")]),e._v(" is "),a("code",[e._v("initial_holders")]),e._v(" and the amount >= "),a("code",[e._v("COMMUNITY_NODE_MIN_STAKE")])]),e._v(" "),a("li",[e._v("size(Validators in InitChainRequest) == size("),a("code",[e._v("Vec<CouncilNode>")]),e._v(") and for every CouncilNode, its "),a("code",[e._v("consensus_pubkey")]),e._v(" appears in Validators and power in Validators corresponds to staking address’ amount")])]),e._v(" "),a("p",[e._v("If valid, the genesis state is then initialized as follows:")]),e._v(" "),a("ol",[a("li",[e._v("initialize RewardsPool’s amount with amounts corresponding to: "),a("code",[e._v("nlt_address")]),e._v(" + "),a("code",[e._v("dist_address1")]),e._v(" + "),a("code",[e._v("dist_address2")])]),e._v(" "),a("li",[e._v("for every council node, create a "),a("code",[e._v("CouncilNode")]),e._v(" structure")]),e._v(" "),a("li",[e._v("for every council node’s staking address and every address in initially bonded: create "),a("code",[e._v("Account")]),e._v(" where all of the corresponding amount is set as "),a("code",[e._v("bonded")])]),e._v(" "),a("li",[e._v("for every address in "),a("code",[e._v("initial_holders")]),e._v(" except for "),a("code",[e._v("nlt_address")]),e._v(", "),a("code",[e._v("dist_address1")]),e._v(", "),a("code",[e._v("dist_address2")]),e._v(", council nodes’ staking addresses, initially bonded addresses: if "),a("code",[e._v("is_contract")]),e._v(" then add the amount to RewardsPool else create "),a("code",[e._v("Account")]),e._v(" where the amount is all in "),a("code",[e._v("unbonded")]),e._v(" and "),a("code",[e._v("unbonded_from")]),e._v(" is set to genesis block’s time (in InitChain)")])])])},[],!1,null,null,null);t.default=n.exports}}]);